<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Fundamentos da Linguagem &mdash; LivroPython v1.0 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/_static/jsMath/easy/load.js"></script>
    <link rel="top" title="LivroPython v1.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             accesskey="I">índice</a></li>
        <li><a href="../index.html">LivroPython v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="fundamentos-da-linguagem">
<h1>Fundamentos da Linguagem<a class="headerlink" href="#fundamentos-da-linguagem" title="Link permanente para este título">¶</a></h1>
<p>Breve introdução a conceitos básicos de programação e à linguagem Python. A maioria dos elementos básicos da linguagem são abordados neste capítulo, com exceção de classes, que são discutidas em detalhe no capítulo \ref{cap:obj}. <strong>Pré-requisitos:</strong> Conhecimentos básicos de programação em qualquer linguagem.</p>
<p>Neste Capítulo, faremos uma breve introdução à linguagem
Python. Esta introdução servirá de base para os exemplos dos
capítulos subseqüentes. Para uma introdução mais completa à
linguagem, recomendamos ao leitor a consulta a livros e outros
documentos voltados especificamente para programação em Python.</p>
<div class="section" id="primeiras-impress-es">
<h2>Primeiras impressões<a class="headerlink" href="#primeiras-impress-es" title="Link permanente para este título">¶</a></h2>
<p>Para uma primeira aproximação à linguagem, vamos examinar suas
características básicas. Façamos isso interativamente, a partir do
console Python. Vejamos como invocá-lo:</p>
<div class="highlight-python"><pre>$ python
Python 2.5.1 (r251:54863, May  2 2007, 16:56:35)
[GCC 4.1.2 (Ubuntu 4.1.2-0ubuntu4)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;</pre>
</div>
<p>Toda linguagem, seja ela de programação ou linguagem natural, possui um conjunto de palavras que a caracteriza. As linguagens de programação tendem a ser muito mais compactas do que as linguagens naturais. O Python pode ser considerado uma linguagem compacta, mesmo em comparação com outras linguagens de programação.</p>
<p>As palavras que compõem uma linguagem de programação são ditas reservadas, ou seja, não podem ser utilizadas para nomear variáveis. Se o programador tentar utilizar uma das palavras reservadas como variável, incorrerá em um erro de sintaxe.
Palavras reservadas não podem ser utilizadas como nomes de variáveis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span><span class="o">=</span><span class="mi">1</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
    <span class="k">for</span><span class="o">=</span><span class="mi">1</span>
       <span class="o">^</span>
<span class="nc">SyntaxError</span>: <span class="n-Identifier">invalid syntax</span>
</pre></div>
</div>
<p>A linguagem Python em sua versão atual (2.5), possui 30 palavras reservadas. São elas: <em>and</em>, <em>as</em>, <em>assert</em>, <em>break</em>, <em>class</em>, <em>continue</em>, <em>def</em>, <em>del</em>, <em>elif</em>, <em>else</em>, <em>except</em>, <em>exec</em> <em>finally</em>, <em>for</em>, <em>from</em>, <em>global</em>, <em>if</em>, <em>import</em>, <em>in</em>, <em>is</em>, <em>lambda</em>, <em>not</em>, <em>or</em>, <em>pass</em>, <em>print</em>, <em>raise</em>, <em>return</em>, <em>try</em>, <em>while</em> e <em>yield</em>. Além destas palavras, existem constantes, tipos e funções internas ao Python, que estão disponíveis para a construção de programas. Estes elementos podem ser inspecionados através do comando <em>dir(__builtins__)</em>. Nenhum dos elementos do módulo <a href="#id1"><span class="problematic" id="id2">*</span></a>__builtins__} deve ser redefinidofootnote{Atenção, os componentes de __builtins__, não geram erros de sintaxe ao ser redefinidos.}.
index{Palavras reservadas}
O console interativo do Python possui um sistema de ajuda integrado que pode ser usado para acessar a documentação de qualquer elemento da linguagem. O comando <a href="#id3"><span class="problematic" id="id4">*</span></a>help()}, inicia a ajuda interativa. A partir daí, podemos por exemplo, digitar <a href="#id5"><span class="problematic" id="id6">*</span></a>keywords} para acessar a ajuda das palavras reservadas listadas acima. Se digitarmos <a href="#id7"><span class="problematic" id="id8">*</span></a>for} em seguida, obteremos a seguinte ajuda:
begin{lstlisting}[frame=trBL, caption= Definição da palavra reservada <a href="#id9"><span class="problematic" id="id10">*</span></a>for}.,label=]
7.3 The for statement</p>
<blockquote>
The for statement is used to iterate over the elements of a sequence
(such as a string, tuple or list) or other iterable object:</blockquote>
<p>...
end{lstlisting}</p>
<p>section{Uso Interativo emph{vs.} Execução a Partir de Scripts}
Usuários familiarizados com ambientes de programação científicos tais como Matlab, R e similares, ficarão satisfeitos em saber que o Python também pode ser utilizado de forma interativa. Para isso, basta invocar o interpretador na linha de comando (Python shell, em Unix) ou invocar um shell mais sofisticado como o Idle, que vem com a distribuição padrão do Python, ou o Ipython (ver ref{sec:ipython}).</p>
<p>index{uso interativo}</p>
<p>Tanto no uso interativo, como na execução a partir de scripts, o interpretador espera encontrar apenas uma expressão por linha do programa. Caso se deseje inserir mais de uma expressão em uma linha, as expressões devem ser separadas por <a href="#id11"><span class="problematic" id="id12">*</span></a>;}. Mas esta prática deve ser evitada. Expressões podem continuar em outra linha se algum de seus parênteses, colchetes, chaves ou aspas ainda não tiver sido fechado. Alternativamente, linhas podem ser quebradas pela aposição do caractere verb|| ao final da linha.</p>
<p>begin{lstlisting}[caption=Usando o Python como uma calculadora., label=ex:calc]
&gt;&gt;&gt; 1+1
2
&gt;&gt;&gt;
end{lstlisting}
No cabeçalho da shell do Python, acima (listagem ref{ex:conspy}), o interpretador identifica a versão instalada, data e hora em que foi compilada, o compilador C utilizado, detalhes sobre o sistema operacional e uma linhazinha de ajuda para situar o novato.</p>
<p>Para executar um programa, a maneira usual (em Unix) é digitar: <em>python script.py}. No Windows basta um duplo clique sobre arquivos *</em>.py}.</p>
<p>begin{lstlisting}[caption=Executando script.py via comando de linha., label=ex:script]
$`</p>
<blockquote>
python script.py</blockquote>
<p>No Linux e em vários UNIXes, podemos criar scripts que são
executáveis diretamente, sem precisar invocar o interpretador
antes. Para isso, basta incluir a seguinte linha no topo do nosso
script:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
</pre></div>
</div>
<p>Note que os caracteres {\#!} devem ser os dois primeiros
caracteres do arquivo (como na listagem ex:exec):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>

<span class="k">print</span> <span class="s">&quot;Alô Mundo!&quot;</span>
</pre></div>
</div>
<p>Depois, resta apenas ajustar as permissões do arquivo para que
possamos executá-lo: <tt class="docutils literal"><span class="pre">chmod</span> <span class="pre">+x</span> <span class="pre">script.py</span></tt> (listagem ex:chmod).</p>
<blockquote>
:math:<a href="#id13"><span class="problematic" id="id14">`</span></a>$ chmod +x script.py</blockquote>
<dl class="docutils">
<dt>$` ./script.py sys:1:</dt>
<dd>DeprecationWarning: Non-ASCII character &#8216;4&#8217; in file ./teste on line
3, but no encoding declared; see
<a class="reference external" href="http://www.python.org/peps/pep-0263.html">http://www.python.org/peps/pep-0263.html</a> for details Alô Mundo!</dd>
</dl>
<p>Mas que lixo é aquele antes do nosso &#8220;<strong>Alô mundo</strong>&#8220;? Trata-se do
interpretador reclamando do acento circunflexo em &#8220;<strong>Alô</strong>&#8220;. Para
que o Python não reclame de acentos e outros caracteres da língua
portuguesa não contidos na tabela ASCII, precisamos adicionar a
seguinte linha ao script: # -*- coding: latin-1 -*-.
Experimente editar o script acima e veja o resultado.</p>
<p>No exemplo da listagem ex:exec, utilizamos o comando <tt class="docutils literal"><span class="pre">print</span></tt> para
fazer com que nosso script produzisse uma string como saída, ou
seja, para escrever no stdout <a class="footnote-reference" href="#id127" id="id15">[1]</a>. Como podemos receber
informações pelo <tt class="docutils literal"><span class="pre">stdin</span></tt>? O Python nos oferece duas funções para
isso: <tt class="docutils literal"><span class="pre">input('texto')</span></tt>, que executa o que o usuário digitar,
sendo portanto perigoso, e {raw\_input(&#8216;texto&#8217;)}, que retorna uma
string com a resposta do usuário.</p>
<p>Nas listagens que se seguem, alternaremos entre a utilização de
scripts e a utilização do Python no modo interativo (como na
listagem ex:calc). A presença do símbolo &#8220;{&gt;&gt;&gt;}&#8221;, característico da
shell do Python será suficiente para diferenciar os dois casos.
Exemplos de scripts virão dentro de caixas.</p>
<div class="section" id="opera-es-com-n-meros">
<h3>Operações com Números<a class="headerlink" href="#opera-es-com-n-meros" title="Link permanente para este título">¶</a></h3>
<p>Noventa e nove por cento das aplicações científicas envolvem algum
tipo de processamento numérico. Vamos iniciar nosso contato com o
Python através dos números (Listagem ex:arit).</p>
<blockquote>
2+2 4 Comentário ... 2*2 4 2**2 Comentário na mesma linha 4
(50-5*6)/4 5 Divisão de inteiros retorna &#8220;floor&#8221;: ... 7/3 2 7/-3
-3 7/3. 2.3333333333333335</blockquote>
<p>{operadores aritméticos} Nosso primeiro exemplo numérico (Listagem
ex:arit) <a class="footnote-reference" href="#id128" id="id16">[2]</a>, trata números em sua representação mais simples:
como constantes. É desta forma que utilizamos uma calculadora
comum. Em programação é mais comum termos números associados a
quantidades, a que precisamos nos referenciar e que podem se
modificar. Esta representação de números chama-se variável.</p>
<p>O sinal de <tt class="docutils literal"><span class="pre">=</span></tt> é utilizado para atribuir valores a
variáveis(Listagem ex:atr).</p>
<blockquote>
largura = 20 altura = 5*9 largura * altura 900</blockquote>
<p>Um valor pode ser atribuído a diversas variáveis com uma única
operação de atribuição, ou múltiplos valores a múltiplas variáveis
(Listagem ex:multatr). Note que no exemplo de atribuição de
múltiplos valores a múltiplas variáveis (Listagem ex:multatr, linha
9) os valores poderiam estar em uma tupla.</p>
<blockquote>
x = y = z = 0 Zero x, y e z x 0 y 0 z 0 a,b,c=1,2,3 a 1 b 2 c 3</blockquote>
<p>O Python também reconhece números reais (ponto-flutuante) e
complexos naturalmente. Em operações entre números reais e inteiros
o resultado será sempre real. Da mesma forma, operações entre
números reais e complexos resultam sempre em um número complexo.
Números complexos são sempre representados por dois números
ponto-flutuante: a parte real e a parte imaginária. A parte
imaginária é representada com um sufixo &#8220;j&#8221; ou &#8220;J&#8221;.</p>
<blockquote>
1j * 1J (-1+0j) 1j * complex(0,1) (-1+0j) 3+1j*3 (3+3j)
(3+1j)*3 (9+3j) (1+2j)/(1+1j) (1.5+0.5j)</blockquote>
<p>{Números complexos} Um Número complexo para o Python, é um
objeto <a class="footnote-reference" href="#id129" id="id17">[3]</a>. Podemos extrair as partes componentes de um número
complexo <tt class="docutils literal"><span class="pre">c</span></tt> utilizando atributos do tipo complexo: <tt class="docutils literal"><span class="pre">c.real</span></tt> e
<tt class="docutils literal"><span class="pre">c.imag</span></tt>. A função <tt class="docutils literal"><span class="pre">abs</span></tt>, que retorna o módulo de um numero
inteiro ou real, retorna o comprimento do vetor no plano complexo,
quando aplicada a um número complexo. O módulo de um número
complexo é também denominado magnitude (listagem ex:complex2).</p>
<blockquote>
a=3.0+3.0j a.real 3.0 a.imag 3.0 abs(a) sqrt(a.real**2 +
a.imag**2) 4.2426406871192848</blockquote>
</div>
</div>
<div class="section" id="nomes-objetos-e-espa-os-de-nomes">
<h2>Nomes, Objetos e Espaços de Nomes<a class="headerlink" href="#nomes-objetos-e-espa-os-de-nomes" title="Link permanente para este título">¶</a></h2>
<p>{espaço de nomes} Nomes em Python são identificadores de objetos, e
também são chamados de variáveis. Nomes devem ser iniciados por
letras maiúsculas ou minúsculas e podem conter algarismos, desde
que não sejam o primeiro caractere. O Python faz distinção entre
maiúsculas e minúsculas portanto, <tt class="docutils literal"><span class="pre">nome</span> <span class="pre">!=</span> <span class="pre">Nome</span></tt>.</p>
<p>No Python, todos os dados são objetos tipados, que são associados
dinamicamente a nomes. O sinal de igual (<tt class="docutils literal"><span class="pre">=</span></tt>), liga o resultado
da avaliação da expressão do seu lado direito a um nome situado à
sua esquerda. A esta operação damos o nome de atribuição (ver
exemplo na listagem ex:attr).</p>
<blockquote>
a=3*2**7 a,b = (&#8216;laranja&#8217;,&#8217;banana&#8217;)</blockquote>
<p>As variáveis criadas por atribuição ficam guardadas na memória do
computador. Para evitar preenchimento total da memória, assim que
um objeto deixa de ser referenciado por um nome (deixa de existir
no espaço de nomes corrente), ele é imediatamente apagado da
memória pelo interpretador.</p>
<p>O conceito de espaço de nomes é uma característica da linguagem
Python que contribui para sua robustez e eficiência. Espaços de
nomes são dicionários (ver ss:dict) contendo as variáveis, objetos
e funções disponíveis durante a execução de um programa. A um dado
ponto da execução de um programa, existem sempre dois dicionários
disponíveis para a resolução de nomes: um local e um global. Estes
dicionários podem ser acessados para leitura através das funções
<tt class="docutils literal"><span class="pre">locals()</span></tt> e <tt class="docutils literal"><span class="pre">globals()</span></tt>, respectivamente. Sempre que o
interpretador Python encontra uma palavra que não pertence ao
conjunto de palavras reservadas da linguagem, ele a procura,
primeiro no espaço de nomes local e depois no global. Se a palavra
não é encontrada, um erro do tipo <tt class="docutils literal"><span class="pre">NameError</span></tt> é acionado (exemplo
ex:nameerror).</p>
<blockquote>
maria Traceback (most recent call last): File &#8220;stdin&#8221;, line 1, in ?
NameError: name &#8216;maria&#8217; is not defined</blockquote>
<p>O espaço de nomes local, muda ao longo da execução de um programa.
Toda a vez que a execução adentra uma função, o espaço de nomes
local passa a refletir apenas as variáveis definidas dentro daquela
função <a class="footnote-reference" href="#id130" id="id18">[4]</a>. Ao sair da função, o dicionário local torna-se igual
ao global.</p>
<blockquote>
a=1 len(globals().items()) 4 len(locals().items()) 4 def fun(): ...
a=&#8217;novo valor&#8217; ... print len(locals().items()) ... print a ...
fun() 1 novo valor print a 1 len(locals().items()) 5 locals()
&#8216;builtins&#8217;: module &#8216;builtin&#8217; (built-in), &#8216;name&#8217;: &#8216;main&#8217;, &#8216;fun&#8217;:
function fun at 0xb7c18ed4, &#8216;doc&#8217;: None, &#8216;a&#8217;: 1</blockquote>
<p>Também é importante lembrar que o espaço de nomes local sempre
inclui os {\_\_builtins\_\_} como vemos na listagem
ex:locals.</p>
</div>
<div class="section" id="estruturas-de-dados">
<h2>Estruturas de Dados<a class="headerlink" href="#estruturas-de-dados" title="Link permanente para este título">¶</a></h2>
<p>Qualquer linguagem de programação pode ser simplisticamente
descrita como uma ferramenta, através da qual, dados e algoritmos
são implementados e interagem para a solução de um dado problema.
Nesta seção vamos conhecer os tipos e estruturas de dados do Python
para que possamos, mais adiante, utilizar toda a sua flexibilidade
em nossos programas.</p>
<p>No Python, uma grande ênfase é dada à simplicidade e à
flexibilidade de forma a maximizar a produtividade do programador.
No tocante aos tipos e estruturas de dados, esta filosofia se
apresenta na forma de uma tipagem dinâmica, porém forte. Isto quer
dizer que os tipos das variáveis não precisam ser declarados pelo
programador, como é obrigatório em linguagens de tipagem estática
como o C, FORTRAN, Visual Basic, etc. Os tipos das variáveis são
inferidos pelo interpretador. As principais estruturas de dados
como <tt class="docutils literal"><span class="pre">Listas</span></tt> e <tt class="docutils literal"><span class="pre">Dicionários</span></tt>, podem ter suas dimensões
alteradas, dinamicamente durante a execução do Programa , o que
facilita enormemente a vida do programador, como veremos mais
adiante. {Listas}{listas}</p>
<p>As listas formam o tipo de dados mais utilizado e versátil do
Python. Listas são definidas como uma sequência de valores
separados por vírgulas e delimitada por colchetes:</p>
<blockquote>
lista=[1, &#8216;a&#8217;, &#8216;pe&#8217;] lista [1, &#8216;a&#8217;, &#8216;pe&#8217;] lista[0] 1 lista[2] &#8216;pe&#8217;
lista[-1] &#8216;pe&#8217;</blockquote>
<p>Na listagem ex:lista1, criamos uma lista de três elementos. Uma
lista é uma sequência ordenada de elementos, de forma que podemos
selecionar elementos de uma lista por meio de sua posição. Note que
o primeiro elemento da lista é <tt class="docutils literal"><span class="pre">lista[0]</span></tt>. Todas as contagens em
Python começam em <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>Uma lista também pode possuir elementos de tipos diferentes. Na
listagem ex:lista1, o elemento <tt class="docutils literal"><span class="pre">0</span></tt> é um inteiro enquanto que os
outros elementos são strings. Para verificar isso, digite o comando
<tt class="docutils literal"><span class="pre">type(lista[0])</span></tt>.</p>
<p>Uma característica muito interessante das listas do Python, é que
elas podem ser indexadas de trás para frente, ou seja,
<tt class="docutils literal"><span class="pre">lista[-1]</span></tt> é o último elemento da lista. Como listas são
sequências de tamanho variável, podemos assessar os últimos <strong>n</strong>
elementos, sem ter que contar os elementos da lista.</p>
<p>Listas podem ser &#8220;fatiadas&#8221;, ou seja, podemos selecionar uma porção
de uma lista que contenha mais de um elemento.</p>
<blockquote>
lista=[&#8216;a&#8217;,&#8217;pe&#8217;, &#8216;que&#8217;, 1] lista[1:3] [&#8216;pe&#8217;, &#8216;que&#8217;] lista[-1] 1
lista[3] 1</blockquote>
<p>O comando <tt class="docutils literal"><span class="pre">lista[1:3]</span></tt>, delimita uma &#8220;fatia&#8221; que vai do elemento
<tt class="docutils literal"><span class="pre">1</span></tt> (o segundo elemento) ao elemento imediatamente anterior ao
elemento <tt class="docutils literal"><span class="pre">3</span></tt>. Note que esta seleção inclui o elemento
correspondente ao limite inferior do intervalo, mas não o limite
superior. Isto pode gerar alguma confusão, mas tem suas utilidades.
Índices negativos também podem ser utilizados nestas expressões.</p>
<p>Para retirar uma fatia que inclua o último elemento, temos que usar
uma variação deste comando seletor de intervalos:</p>
<blockquote>
lista[2:] [&#8216;que&#8217;, 1]</blockquote>
<p>Este comando significa todos os elementos a partir do elemento !2!
(o terceiro), até o final da lista. Este comando poderia ser
utilizado para selecionar elementos do início da lista:
<tt class="docutils literal"><span class="pre">lista[:3]</span></tt>, só que desta vez não incluindo o elemento <tt class="docutils literal"><span class="pre">3</span></tt> (o
quarto elemento).</p>
<p>Se os dois elementos forem deixados de fora, são selecionados todos
os elementos da lista:</p>
<blockquote>
lista[:] [&#8216;a&#8217;, &#8216;pe&#8217;, &#8216;que&#8217;, 1]</blockquote>
<p>Só que não é a mesma lista, é uma nova lista com os mesmos
elementos. Desta forma, <tt class="docutils literal"><span class="pre">lista[:]</span></tt> é uma maneira de fazer uma
cópia completa de uma lista. Normalmente este recurso é utilizado
junto com uma atribuição <tt class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">lista[:]</span></tt>.</p>
<blockquote>
lista[:] [&#8216;a&#8217;, &#8216;pe&#8217;, &#8216;que&#8217;, 1] lista.append(2) adiciona 2 ao final
[&#8216;a&#8217;, &#8216;pe&#8217;, &#8216;que&#8217;, 1, 2] lista.insert(2,[&#8216;a&#8217;,&#8217;b&#8217;]) lista [&#8216;a&#8217;,
&#8216;pe&#8217;, [&#8216;a&#8217;, &#8216;b&#8217;], &#8216;que&#8217;, 1, 2]</blockquote>
<p>As listas são conjuntos mutáveis, ao contrário de tuplas e strings,
portanto pode-se adicionar(listagem ex:adlista), modificar ou
remover (tabela tab:metlista) elementos de uma lista.</p>
<p>{listas!métodos}</p>
<p>Note que as operações <em>in situ</em> não alocam memória extra para a
operação, ou seja, a inversão ou a ordenação descritas na tabela
tab:metlista, são realizadas no mesmo espaço de memória da lista
original. Operações <em>in situ</em> alteram a variável em si sem fazer
uma cópia da mesma e, portanto não retornam nada.</p>
<p>O método <tt class="docutils literal"><span class="pre">L.insert</span></tt> insere um objeto antes da posição indicada
pelo índice. Repare, na listagem ex:adlista, que o objeto em
questão era uma lista, e o método insert não a fundiu com a lista
original. Este exemplo nos mostra mais um aspecto da versatilidade
do objeto lista, que pode ser composto por objetos de qualquer
tipo.</p>
<blockquote>
lista2=[&#8216;a&#8217;,&#8217;b&#8217;] lista.extend(lista2) lista [&#8216;a&#8217;, &#8216;pe&#8217;, [&#8216;a&#8217;, &#8216;b&#8217;],
&#8216;que&#8217;, 1, 2, &#8216;a&#8217;, &#8216;b&#8217;]</blockquote>
<p>Já na listagem ex:extlista, os elementos da segunda lista são
adicionados, individualmente, ao final da lista original.</p>
<blockquote>
lista.index(&#8216;que&#8217;) 3 lista.index(&#8216;a&#8217;) 0 lista.index(&#8216;z&#8217;) Traceback
(most recent call last): File &#8220;input&#8221;, line 1, in ? ValueError:
list.index(x): x not in list &#8216;z&#8217; in lista 0</blockquote>
<p>Conforme ilustrado na listagem ex:buslista, o método <tt class="docutils literal"><span class="pre">L.index</span></tt>
retorna o índice da primeira ocorrência do valor dado. Se o valor
não existir, o interpretador retorna um <tt class="docutils literal"><span class="pre">ValueError</span></tt>. Para testar
se um elemento está presente em uma lista, pode-se utilizar o
comando <tt class="docutils literal"><span class="pre">in</span></tt> <a class="footnote-reference" href="#id131" id="id19">[5]</a> como ilustrado na listagem ex:buslista. Caso o
elemento faça parte da lista, este comando retornará <tt class="docutils literal"><span class="pre">1</span></tt>, caso
contrário retornará <tt class="docutils literal"><span class="pre">0</span></tt> <a class="footnote-reference" href="#id132" id="id20">[6]</a>.</p>
<p>Existem dois métodos básicos para remover elementos de uma lista:
<tt class="docutils literal"><span class="pre">L.remove</span></tt> e <tt class="docutils literal"><span class="pre">L.pop</span></tt> &#8211; listagem ex:remlista. O primeiro remove
o elemento nomeado sem nada retornar, o segundo elimina e retorna o
último ou o elemento da lista (se chamado sem argumentos), ou o
determinado pelo índice, passado como argumento (Listagem
ex:remlista).</p>
<blockquote>
lista.remove(&#8220;que&#8221;) lista [&#8216;a&#8217;, &#8216;pe&#8217;, [&#8216;a&#8217;, &#8216;b&#8217;], 1, 2, &#8216;a&#8217;, &#8216;b&#8217;]
lista.pop(2) [&#8216;a&#8217;, &#8216;b&#8217;] lista [&#8216;a&#8217;, &#8216;pe&#8217;, 1, 2, &#8216;a&#8217;, &#8216;b&#8217;]</blockquote>
<p>Operadores aritméticos também podem ser utilizados para operações
com listas. O operador de soma, &#8220;<tt class="docutils literal"><span class="pre">+</span></tt>&#8220;, concatena duas listas. O
operador &#8220;<tt class="docutils literal"><span class="pre">+=</span></tt>&#8221; é um atalho para o método <tt class="docutils literal"><span class="pre">L.extend</span></tt> conforme
mostrado na listagem ex:oplista.</p>
<blockquote>
lista=[&#8216;a&#8217;, &#8216;pe&#8217;, 1, 2, &#8216;a&#8217;, &#8216;b&#8217;] lista = lista + [&#8216;novo&#8217;,
&#8216;elemento&#8217;] lista [&#8216;a&#8217;, &#8216;pe&#8217;, 1, 2, &#8216;a&#8217;, &#8216;b&#8217;, &#8216;novo&#8217;, &#8216;elemento&#8217;]
lista += &#8216;dois&#8217; lista [&#8216;a&#8217;, &#8216;pe&#8217;, 1, 2, &#8216;a&#8217;, &#8216;b&#8217;, &#8216;d&#8217;, &#8216;o&#8217;, &#8216;i&#8217;,
&#8216;s&#8217;] lista += [&#8216;dois&#8217;] lista [&#8216;a&#8217;, &#8216;pe&#8217;, 1, 2, &#8216;a&#8217;, &#8216;b&#8217;, &#8216;d&#8217;, &#8216;o&#8217;,
&#8216;i&#8217;, &#8216;s&#8217;, &#8216;dois&#8217;] li=[1,2] li*3 [1, 2, 1, 2, 1, 2]</blockquote>
<p>Note que a operação <tt class="docutils literal"><span class="pre">lista</span> <span class="pre">=</span> <span class="pre">lista</span> <span class="pre">+</span> <span class="pre">lista2</span></tt> cria uma nova
<tt class="docutils literal"><span class="pre">lista</span></tt> enquanto que o comando <tt class="docutils literal"><span class="pre">+=</span></tt> aproveita a lista original
e a extende. Esta diferença faz com que o operador <tt class="docutils literal"><span class="pre">+=</span></tt> seja
muito mais rápido, especialmente para grandes listas. O operador de
multiplicação, <tt class="docutils literal"><span class="pre">``*''</span></tt>, é um repetidor/concatenador de listas
conforme mostrado ao final da listagem ex:oplista. A operação de
multiplicação <a href="#id21"><span class="problematic" id="id22">*</span></a>in situ*(<tt class="docutils literal"><span class="pre">*=</span></tt>) também é válida.</p>
<p>Um tipo de lista muito útil em aplicações científicas, é lista
numérica sequencial. Para construir estas listas podemos utilizar o
comando <tt class="docutils literal"><span class="pre">range</span></tt> (exemplo ex:range). O comando <tt class="docutils literal"><span class="pre">range</span></tt> aceita 1,
2 ou três argumentos: início, fim e passo, respectivamente (ver
exemplo ex:range).</p>
<blockquote>
range(10) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] range(2,20,2)números pares
[2, 4, 6, 8, 10, 12, 14, 16, 18] range(1,20,2)números ímpares [1,
3, 5, 7, 9, 11, 13, 15, 17, 19]</blockquote>
<div class="section" id="tuplas">
<h3>Tuplas<a class="headerlink" href="#tuplas" title="Link permanente para este título">¶</a></h3>
<p>{tuplas} Uma tupla, é uma lista imutável, ou seja, ao contrário de
uma lista, após a sua criação, ela não pode ser alterada. Uma tupla
é definida de maneira similar a uma lista, com exceção dos
delimitadores do conjunto de elementos que no caso de uma tupla são
parênteses (listagem ex:criatupla).</p>
<blockquote>
tu = (&#8216;Genero&#8217;, &#8216;especie&#8217;, &#8216;peso&#8217;, &#8216;estagio&#8217;) tu[0] &#8216;Genero&#8217;
tu[1:3] (&#8216;especie&#8217;, &#8216;peso&#8217;)</blockquote>
<p>Os elementos de uma tupla podem ser referenciados através de
índices, (posição) de forma idêntica a como é feito em listas.
Tuplas também podem ser fatiadas, gerando outras tuplas.</p>
<p>As tuplas não possuem métodos. Isto se deve ao fato de as tuplas
serem imutáveis. Os métodos <tt class="docutils literal"><span class="pre">append</span></tt>, <tt class="docutils literal"><span class="pre">extend</span></tt>, e <tt class="docutils literal"><span class="pre">pop</span></tt>
naturalmente não se aplicam a tuplas, uma vez que não se pode
adicionar ou remover elementos de uma tupla. Não podemos fazer
busca em tuplas, visto que não dispomos do método <tt class="docutils literal"><span class="pre">index</span></tt>. No
entanto, podemos usar <tt class="docutils literal"><span class="pre">in</span></tt> para determinar se um elemento existe
em uma tupla, como se faz em listas.</p>
<blockquote>
tu=() tu () tu=&#8217;casa&#8217;, -Repare na vírgula ao final! tu (&#8216;casa&#8217;,)
tu=1,2,3,4 tu (1, 2, 3, 4) var =w,x,y,z var (w,x,y,z) var = tu w 1
x 2 y 3 z 4</blockquote>
<p>Conforme exemplificado em ex:criatupla2, uma tupla vazia, é
definida pela expressão <tt class="docutils literal"><span class="pre">()</span></tt>, já no caso de uma tupla unitária,
isto é, com apenas um elemento, fazemos a atribuição com uma
vírgula após o elemento, caso contrário (<tt class="docutils literal"><span class="pre">tu=('casa')</span></tt> ), o
interpretador não poderá distinguir se os parênteses estão sendo
utilizados como delimitadores normais ou delimitadores de tupla. O
comando <tt class="docutils literal"><span class="pre">tu=('casa',)</span></tt> é equivalente ao apresentado na quarta
linha da listagem ex:criatupla2, apenas mais longo.</p>
<p>Na sétima linha da listagem ex:criatupla2, temos uma extensão do
conceito apresentado na linha anterior: a definição de uma tupla
sem a necessidade de parênteses. A este processo, se dá o nome de
<em>empacotamento de sequência</em>. O empacotamento de vários elementos
sempre gera uma tupla.</p>
<p>As tuplas, apesar de não serem tão versáteis quanto as listas, são
mais rápidas. Portanto, sempre que se precisar de uma sequênca de
elementos para servir apenas de referência, sem a necessidade de
edição, deve-se utilizar uma tupla. Tuplas também são úteis na
formatação de strings como veremos na listagem ex:formstring.</p>
<p>Apesar das tuplas serem imutáveis, pode-se contornar esta limitação
fatiando e concatenando tuplas. Listas também podem ser convertidas
em tuplas, com a função <tt class="docutils literal"><span class="pre">tuple(lista)</span></tt>, assim como tuplas podem
ser convertidas em listas através da função <tt class="docutils literal"><span class="pre">list(tupla)</span></tt>.</p>
<p>Uma outra aplicação interessante para tuplas, mostrada na listagem
ex:criatupla2, é a atribuição múltipla, em que uma tupla de
valores, é atribuída a uma lista de nomes de variáveis armazenados
em uma tupla. Neste caso, as duas sequências devem ter, exatamente,
o mesmo número de elementos.</p>
</div>
<div class="section" id="strings">
<h3>Strings<a class="headerlink" href="#strings" title="Link permanente para este título">¶</a></h3>
<p>{strings} Strings são um terceiro tipo de sequências em Python.
Strings são sequências de caracteres delimitados por aspas simples,
<tt class="docutils literal"><span class="pre">'string345'</span></tt> ou duplas <tt class="docutils literal"><span class="pre">&quot;string&quot;</span></tt>. Todos os operadores
discutidos até agora para outras sequências, tais como <tt class="docutils literal"><span class="pre">+</span></tt>,
<tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">s[i]</span></tt> e <tt class="docutils literal"><span class="pre">s[i:j]</span></tt>, também são
válidos para strings. Strings também podem ser definidas com três
aspas (duplas ou simples). Esta última forma é utilizada para
definir strings contendo quebras de linha.</p>
<blockquote>
st=&#8216;123 de oliveira4&#8217; len(st) 16 min(st) &#8216; &#8216; max(st) &#8216;v&#8217; texto =
&#8220;&#8221;&#8220;primeira linha segunda linha terceira linha&#8221;&#8220;&#8221; print texto
primeira linha segunda linha terceira linha</blockquote>
<p>Conforme ilustrado na listagem ex:string, uma string é uma
sequência de quaisquer caracteres alfanuméricos, incluindos
espaços. A função <tt class="docutils literal"><span class="pre">len()</span></tt>, retorna o comprimento da string, ou de
uma lista ou tupla. As funções <tt class="docutils literal"><span class="pre">min()</span></tt> e <tt class="docutils literal"><span class="pre">max()</span></tt> retornam o
valor mínimo e o máximo de uma sequência, respectivamente. Neste
caso, como a sequência é uma string, os valores são os códigos
ASCII de cada caracter. Estes comandos também são válidos para
listas e tuplas.</p>
<p>O tipo String possui 33 métodos distintos (na versão 2.2.1 do
Python). Seria por demais enfadonho listar e descrever cada um
destes métodos neste capítulo. Nesta seção vamos ver alguns métodos
de strings em ação no contexto de alguns exemplos. Outros métodos
aparecerão em outros exemplos nos demais capítulos.</p>
<p>O uso mais comum dado a strings é a manipulação de textos que fazem
parte da entrada ou saída de um programa. Nestes casos, é
interessante poder montar strings, facilmente, a partir de outras
estruturas de dados. Em Python, a inserção de valores em strings
envolve o marcador {\%s}.</p>
<blockquote>
<p>animal=&#8217;Hamster 1&#8217; peso=98 &#8216;</p>
<p>&#8216;Hamster 1: 98 gramas&#8217;</p>
</blockquote>
<p>{strings!formatando}</p>
<p>Na listagem ex:formstring, temos uma expressão de sintaxe não tão
óbvia mas de grande valor na geração de strings. O operador {\%}
(módulo), indica que os elementos da tupla seguinte serão mapeados,
em sequência, nas posições indicadas pelos marcadores {\%s} na
string.</p>
<p>Esta expressão pode parecer uma complicação desnecessária para uma
simples concatenação de strings. Mas não é. Vejamos porquê:</p>
<blockquote>
<p>animal=&#8217;Hamster 1&#8217; peso=98 &#8216;</p>
<p>&#8216;Hamster 1: 98 gramas&#8217; animal+&#8217;: &#8216;+peso+&#8217; gramas&#8217; Traceback (most
recent call last): File &#8220;input&#8221;, line 1, in ? TypeError: cannot
concatenate &#8216;str&#8217; and &#8216;int&#8217; objects</p>
</blockquote>
<p>Pelo erro apresentado na listagem ex:concstring, vemos que a
formatação da string utilizando o operador módulo e os marcadores
{\%s}, faz mais do que apenas concatenar strings, também converte
a variável <strong>peso</strong> (inteiro) em uma string.
{Dicionários}(ss:dict){dicionários} O dicionário é um tipo de dado
muito interessante do Python: É uma estrutura que funciona como um
banco de dados em miniatura, no sentido de que seus elementos
consistem de pares &#8220;<strong>chave : valor</strong>&#8220;, armazenados sem ordenação.
Isto significa que não existem índices para os elementos de um
dicionário, a informação é acessada através das chaves.</p>
<blockquote>
Z=&#8217;C&#8217;:12, &#8216;O&#8217;:16, &#8216;N&#8217;:12, &#8216;Na&#8217;:40 Z[&#8216;O&#8217;] 16 Z[&#8216;H&#8217;]=1 Z &#8216;Na&#8217;: 40,
&#8216;C&#8217;: 12, &#8216;H&#8217;: 1, &#8216;O&#8217;: 16, &#8216;N&#8217;: 12 Z.keys() [&#8216;Na&#8217;, &#8216;C&#8217;, &#8216;H&#8217;, &#8216;O&#8217;,
&#8216;N&#8217;] Z.haskey(&#8216;N&#8217;) 1</blockquote>
<p>As chaves podem ser de qualquer tipo imutável: números, strings,
tuplas (que contenham apenas tipos imutáveis). Dicionários possuem
os métodos listados na tabela tab:metdic.</p>
<p>Os conjuntos (chave:valor) são chamados de ítens do dicionários.
Esta terminologia é importante pois podemos acessar, separadamente,
chaves, valores ou ítens de um dicionário.</p>
<p>Os valores de um dicionário podem ser de qualquer tipo, números,
strings, listas, tuplas e até mesmo outros dicionários. Também não
há qualquer restrição para o armazenamento de diferentes tipos de
dados em um mesmo dicionário.</p>
<p>Conforme exemplificado em ex:criadic, pode-se adicionar novos ítens
a um dicionário, a qualquer momento, bastando atribuir um valor a
uma chave. Contudo, é preciso ter cuidado. Se você tentar criar um
ítem com uma chave que já existe, o novo ítem substituirá o
antigo.</p>
<p>{dicionários!métodos}</p>
<p>Os métodos !D.iteritems()!, <tt class="docutils literal"><span class="pre">D.iterkeys()</span></tt> e <tt class="docutils literal"><span class="pre">D.itervalues()</span></tt>
criam iteradores. Iteradores permitem iterar através dos ítens,
chaves ou valores de um dicionário. Veja a listagem ex:iterdic:</p>
<blockquote>
Z.items() [(&#8216;Na&#8217;, 40), (&#8216;C&#8217;, 12), (&#8216;H&#8217;, 1), (&#8216;O&#8217;, 16), (&#8216;N&#8217;, 12)]
i=Z.iteritems() i dictionary-iterator object at 0x8985d00 i.next()
(&#8216;Na&#8217;, 40) i.next() (&#8216;C&#8217;, 12) e assim por diante... k=Z.iterkeys()
k.next() &#8216;Na&#8217; k.next() &#8216;C&#8217; k.next() &#8216;H&#8217; k.next() &#8216;O&#8217; k.next() &#8216;N&#8217;
k.next() Traceback (most recent call last): File &#8220;input&#8221;, line 1,
in ? StopIteration</blockquote>
<p>O uso de iteradores é interessante quando se precisa acessar o
conteúdo de um dicionário, elemento-a-elemento, sem repetição. Ao
final da iteração, o iterador retorna um aviso: <tt class="docutils literal"><span class="pre">StopIteration</span></tt>.</p>
</div>
<div class="section" id="conjuntos">
<h3>Conjuntos<a class="headerlink" href="#conjuntos" title="Link permanente para este título">¶</a></h3>
<p>{conjuntos} Reafirmando sua vocação científica, a partir da versão
2.4, uma estrutura de dados para representar o conceito matemático
de conjunto foi introduzida na linguagem Python. Um conjunto no
Python é uma coleção de elementos sem ordenação e sem repetições. O
objeto conjunto em Python aceita operações matemáticas de conjuntos
tais como união, interseção, diferença e diferença simétrica
(exemplo ex:conjuntos).</p>
<blockquote>
a = set(&#8216;pirapora&#8217;) b = set(&#8216;paranapanema&#8217;) a letras em a set([&#8216;i&#8217;,
&#8216;p&#8217;, &#8216;r&#8217;, &#8216;a&#8217;, &#8216;o&#8217;]) a - b Letras em a mas não em b set([&#8216;i&#8217;, &#8216;o&#8217;])
a b letras em a ou b set([&#8216;a&#8217;, &#8216;e&#8217;, &#8216;i&#8217;, &#8216;m&#8217;, &#8216;o&#8217;, &#8216;n&#8217;, &#8216;p&#8217;, &#8216;r&#8217;])
a b letras em a e b set([&#8216;a&#8217;, &#8216;p&#8217;, &#8216;r&#8217;]) a b letras em a ou b mas
não em ambos set([&#8216;i&#8217;, &#8216;m&#8217;, &#8216;e&#8217;, &#8216;o&#8217;, &#8216;n&#8217;])</blockquote>
<p>No exemplo ex:conjuntos pode-se observar as seguintes
correspondências entre a notação do Python e a notação matemática
convencional:</p>
<dl class="docutils">
<dt>a - b:</dt>
<dd><p class="first"><span class="math">$A-B$</span> <a class="footnote-reference" href="#id133" id="id23">[7]</a></p>
<p>[a <span class="math">$\mid$</span> b:] <span class="math">$A\cup B$</span></p>
<p>[a &amp; b:] <span class="math">$A\cap B$</span></p>
<p class="last">[a <span class="math">$\hat{ }$</span> b:] <span class="math">$(A\cup B)-(A\cap B)$</span></p>
</dd>
</dl>
</div>
</div>
<div class="section" id="controle-de-fluxo">
<h2>Controle de fluxo<a class="headerlink" href="#controle-de-fluxo" title="Link permanente para este título">¶</a></h2>
<p>Em condições normais o interpretador executa as linhas de um
programa uma a uma. As exceções a este caso são linhas pertencentes
à definição de função e classe, que são executadas apenas quando a
respectiva função ou classe é chamada. Entretanto algumas palavras
reservadas tem o poder de alterar a direção do fluxo de execução
das linhas de um programa. {Condições} Toda linguagem de
programação possui estruturas condicionais que nos permitem
representar decisões:
&#8220;se isso, faça isso, caso contrário faça aquilo&#8221;. Estas estruturas
também são conhecidas por ramificações. O Python nos disponibiliza
três palavras reservadas para este fim: <tt class="docutils literal"><span class="pre">if</span></tt> , <tt class="docutils literal"><span class="pre">elif</span></tt> e
<tt class="docutils literal"><span class="pre">else</span></tt>. O seu uso é melhor demonstrado através de um exemplo
(Listagem ex:ifelif).</p>
<blockquote>
if a == 1: este bloco é executado se a for 1 pass elif a == 2: este
bloco é executado se a for 2 pass else: este bloco é executado se
se se nenhum dos blocos anteriores tiver sido executado pass</blockquote>
<p>{if}{elif}{else}</p>
<p>No exemplo ex:ifelif, vemos também emprego da palavra reservada
<tt class="docutils literal"><span class="pre">pass</span></tt>, que apesar de não fazer nada é muito útil quando ainda
não sabemos quais devem ser as consequências de determinada
condição.</p>
<p>Uma outra forma elegante e compacta de implementar uma ramificação
condicional da execução de um programa é através de dicionários
(Listagem ex:brdict). As condições são as chaves de um dicionário
cujos valores são funções. Esta solução não contempla o <tt class="docutils literal"><span class="pre">else</span></tt>,
porém.</p>
<blockquote>
desfechos = 1:fun1,2:fun2 desfechos[a]</blockquote>
<div class="section" id="itera-o">
<h3>Iteração<a class="headerlink" href="#itera-o" title="Link permanente para este título">¶</a></h3>
<p>{iteração} Muitas vezes em problemas computacionais precisamos
executar uma tarefa, repetidas vezes. Entretanto não desejamos ter
que escrever os mesmos comandos em sequência, pois além de ser uma
tarefa tediosa, iria transformar nosso &#8220;belo&#8221; programa em algo
similar a uma lista telefônica. A solução tradicional para resolver
este problema é a utilização de laços (loops) que indicam ao
interpretador que ele deve executar um ou mais comandos um número
arbitrário de vezes. Existem vários tipos de laços disponíveis no
Python.</p>
<p>{O laço *while}:}{while} O laço <tt class="docutils literal"><span class="pre">while</span></tt> repete uma tarefa
enquanto uma condição for verdadeira (Listagem ex:loops). Esta
tarefa consiste em um ou mais comandos indentados em relação ao
comando que inicia o laço. O fim da indentação indica o fim do
bloco de instruções que deve ser executado pelo laço.</p>
<blockquote>
while True: passrepete indefinidamente i=0 while i 10: i +=1 print
i saida omitida for i in range(1): print i</blockquote>
<p>{O laço *for}:}{for} O laço <tt class="docutils literal"><span class="pre">for</span></tt> nos permite iterar
sobre uma sequência atribuindo os elementos da mesma a uma
variável, sequencialmente, à medida que prossegue. Este laço se
interrompe automaticamente ao final da sequência.</p>
<p>{Iteração avançada:}O Python nos oferece outras técnicas de
iteração sobre sequências que podem ser bastante úteis na redução
da complexidade do código. No exemplo ex:iterdic nós vimos que
dicionários possuem métodos específicos para iterar sobre seus
componentes. Agora suponhamos que desejássemos iterar sobre uma
lista e seu índice?</p>
<blockquote>
<p>for n,e in enumerate([&#8216;a&#8217;,&#8217;b&#8217;,&#8217;c&#8217;,&#8217;d&#8217;,&#8217;e&#8217;]): print &#8220;</p>
<p>0: a 1: b 2: c 3: d 4: e</p>
</blockquote>
<p>{enumerate} A função <tt class="docutils literal"><span class="pre">enumerate</span></tt> (exemplo ex:enumerate) gera um
iterador similar ao visto no exemplo ex:iterdic. O laço <tt class="docutils literal"><span class="pre">for</span></tt>
chama o método <tt class="docutils literal"><span class="pre">next</span></tt> deste iterador repetidas vezes, até que
receba a mensagem <tt class="docutils literal"><span class="pre">StopIteration</span></tt> (ver exemplo ex:iterdic).</p>
<p>O comando <tt class="docutils literal"><span class="pre">zip</span></tt> nos permite iterar sobre um conjunto de
seqûencias pareando sequencialmente os elementos das múltiplas
listas (exemplo ex:zip).</p>
<blockquote>
<p>perguntas = [&#8216;nome&#8217;,&#8217;cargo&#8217;,&#8217;partido&#8217;] respostas =
[&#8216;Lula&#8217;,&#8217;Presidente&#8217;,&#8217;PT&#8217;] for p,r in zip(perguntas,respostas):
print &#8220;qual o seu</p>
<p>qual o seu nome? Lula qual o seu cargo? Presidente qual o seu
partido? PT</p>
</blockquote>
<p>{zip}</p>
<p>Podemos ainda desejar iterar sobre uma sequência em ordem reversa
(exemplo ex:rev), ou iterar sobre uma sequência ordenada sem
alterar a sequência original (exemplo ex:itsort). Note que no
exemplo ex:itsort, a lista original foi convertida em um conjunto
(<tt class="docutils literal"><span class="pre">set</span></tt>) para eliminar as repetições.</p>
<blockquote>
<p>for i in reversed(range(5)): print i 4 3 2 1 0</p>
<p>for i in sorted(set(l)): print i laranja leite manga ovos uva</p>
</blockquote>
<p>Iterações podem ser interrompidas por meio da palavra reservada
<tt class="docutils literal"><span class="pre">break</span></tt>. Esta pode ser invocada quando alguma condição se
concretiza. Podemos também saltar para a próxima iteração (sem
completar todas as instruções do bloco) por meio da palavra
reservada <tt class="docutils literal"><span class="pre">continue</span></tt>. A palavra reservada <tt class="docutils literal"><span class="pre">else</span></tt> também pode
ser aplicada ao final de um bloco iterativo. Neste caso o bloco
definido por <tt class="docutils literal"><span class="pre">else</span></tt> só será executado se a iteração se completar
normalmente, isto é, sem a ocorrência de <tt class="docutils literal"><span class="pre">break</span></tt>.{break}</p>
</div>
<div class="section" id="lidando-com-erros-exce-es">
<h3>Lidando com erros: Exceções<a class="headerlink" href="#lidando-com-erros-exce-es" title="Link permanente para este título">¶</a></h3>
<p>{try}{except}{finally}{exceções} O método da tentativa e erro não é
exatamente aceito na ortodoxia científica mas, frequentemente, é
utilizado no dia a dia do trabalho científico. No contexto de um
programa, muitas vezes somos forçados a lidar com possibilidades de
erros e precisamos de ferramentas para lidar com eles.</p>
<p>Muitas vezes queremos apenas continuar nossa análise, mesmo quando
certos erros de menor importância ocorrem; outras vezes, o erro é
justamente o que nos interessa, pois nos permite examinar casos
particulares onde nossa lógica não se aplica.</p>
<p>Como de costume o Python nos oferece ferramentas bastante
intuitivas para interação com erros <a class="footnote-reference" href="#id134" id="id24">[8]</a>.</p>
<blockquote>
1/0 Traceback (most recent call last): File &#8220;stdin&#8221;, line 1, in ?
ZeroDivisionError: integer division or modulo by zero</blockquote>
<p>Suponhamos que você escreva um programa que realiza divisões em
algum ponto, e dependendo dos dados fornecidos ao programa, o
denominador torna-se zero. Como a divisão por zero não é possível,
o seu programa para, retornando uma mensagem similar a da listagem
ex:exception. Caso você queira continuar com a execução do programa
apesar do erro, poderíamos solucionar o problema conforme o exposto
na listagem ex:try</p>
<blockquote>
for i in range(5): ... try: ... q=1./i ... print q ... except
ZeroDivisionError: ... print &#8220;Divisão por zero!&#8221; ... Divisão por
zero! 1.0 0.5 0.333333333333 0.25</blockquote>
<p>A construção {try:\ldots except:} nos permite verificar a
ocorrência de erros em partes de nossos programas e responder
adequadamente a ele. o Python reconhece um grande número de tipos
de exceções, chamadas &#8220;built-in exceptions&#8221;. Mas não precisamos
sabê-las de cor, basta causar o erro e anotar o seu nome.</p>
<p>Certas situações podem estar sujeitas à ocorrência de mais de um
tipo de erro. neste caso, podemos passar uma tupla de exceções para
a palavra-chave <tt class="docutils literal"><span class="pre">except</span></tt>:
<tt class="docutils literal"><span class="pre">except</span> <span class="pre">(NameError,</span> <span class="pre">ValueError,IOError):pass</span></tt>, ou simplesmente
não passar nada: <tt class="docutils literal"><span class="pre">except:</span> <span class="pre">pass</span></tt>. Pode acontecer ainda que
queiramos lidar de forma diferente com cada tipo de erro (listagem
ex:multexc).</p>
<blockquote>
<p>try: f = open(&#8216;arq.txt&#8217;) s = f.readline() i = int(s.strip()) except
IOError, (errno, strerror): print &#8220;Erro de I/O (</p>
<p>except ValueError: print &#8220;Não foi possível converter o dado em
Inteiro.&#8221; except: print &#8220;Erro desconhecido.&#8221;</p>
</blockquote>
<p>A construção {try:\ldots except:} acomoda ainda uma cláusula
<tt class="docutils literal"><span class="pre">else</span></tt> opcional, que será executada sempre que o erro esperado
não ocorrer, ou seja, caso ocorra um erro imprevisto a cláusula
<tt class="docutils literal"><span class="pre">else</span></tt> será executada (ao contrário de linhas adicionais dentro
da cláusula <tt class="docutils literal"><span class="pre">try</span></tt>).</p>
<p>Finalmente, <tt class="docutils literal"><span class="pre">try</span></tt> permite uma outra cláusula opcional,
<tt class="docutils literal"><span class="pre">finally</span></tt>, que é sempre executada (quer haja erros quer não). Ela
é util para tarefas que precisam ser executadas de qualquer forma,
como fechar arquivos ou conexões de rede. {Funções}{funções} No
Python, uma função é um bloco de código definido por um cabeçalho
específico e um conjunto de linhas indentadas, abaixo deste.
Funções, uma vez definidas, podem ser chamadas de qualquer ponto do
programa (desde que pertençam ao espaço de nomes). Na verdade, uma
diferença fundamental entre uma função e outros objetos é o fato de
ser &#8220;chamável&#8221;. Isto decorre do fato de todas as funções possuirem
um método <a class="footnote-reference" href="#id135" id="id25">[9]</a> chamado {\_\_call\_\_}. Todos os objetos que
possuam este método poderão ser chamados <a class="footnote-reference" href="#id136" id="id26">[10]</a>.</p>
<p>O ato de chamar um objeto, em Python, é caracterizado pela aposição
de parênteses ao nome do objeto. Por exemplo: <tt class="docutils literal"><span class="pre">func()</span></tt>. Estes
parênteses podem ou não conter &#8220;argumentos&#8221;. Continue lendo para
uma explicação do que são argumentos.</p>
<p>Funções também possuem seu próprio espaço de nomes, ou seja, todas
as variáveis definidas no escopo de uma função só existem dentro
desta. Funções são definidas pelo seguinte cabeçalho:</p>
<blockquote>
def nome(par1, par2, par3=valordefault, *args, **kwargs):</blockquote>
<p>A palavra reservada <tt class="docutils literal"><span class="pre">def</span></tt> indica a definição de uma função; em
seguida deve vir o nome da função que deve seguir as regras de
formação de qualquer nome em Python. Entre parênteses vem,
opcionalmente, uma lista de argumentos que serão ser passados para
a função quando ela for chamada. Argumentos podem ter valores
&#8220;default&#8221; se listados da forma <tt class="docutils literal"><span class="pre">a=1</span></tt>. Argumentos com valores
default devem vir necessariamente após todos os argumentos sem
valores default(Listagem ex:funbas).</p>
<blockquote>
def fun(a,b=1): ... print a,b ... fun(2) 2 1 fun(2,3) 2 3
fun(b=5,2) SyntaxError: non-keyword arg after keyword arg</blockquote>
<p>{funçoes!argumentos opcionais} Por fim, um número variável de
argumentos adicionais pode ser previsto através de argumentos
precedidos por <tt class="docutils literal"><span class="pre">*</span></tt> ou <tt class="docutils literal"><span class="pre">**</span></tt>. No exemplo acima, argumentos
passados anonimamente (não associados a um nome) serão colocados em
uma tupla de nome <tt class="docutils literal"><span class="pre">t</span></tt>, e argumentos passados de forma nominal
(z=2,q=&#8217;asd&#8217;)serão adicionados a um dicionário, chamado
<a href="#id27"><span class="problematic" id="id28">``</span></a>d``(Listagem ex:kwargs).</p>
<blockquote>
def fun(*t, **d): print t, d fun(1,2,c=2,d=4) (1,2)
&#8216;c&#8217;:3,&#8217;d&#8217;:4</blockquote>
<p>{funções!lista de argumentos variável} Funções são chamadas
conforme ilustrado na linha 3 da listagem ex:kwargs. Argumentos
obrigatórios, sem valor &#8220;default&#8221;, devem ser passados primeiro.
Argumentos opcionais podem ser passados fora de ordem, desde que
após os argumentos obrigatórios, que serão atribuídos
sequencialmente aos primeiros nomes da lista definida no cabeçalho
da função(Listagem ex:funbas).</p>
<p>Muitas vezes é conveniente &#8220;desempacotar&#8221; os argumentos passados
para uma função a partir de uma tupla ou dicionário.
{funções!passando argumentos}</p>
<blockquote>
def fun(a,b,c,d): print a,b,c,d t=(1,2);di = &#8216;d&#8217;: 3, &#8216;c&#8217;: 4
fun(*t,**di) 1 2 4 3</blockquote>
<p>Argumentos passados dentro de um dicionário podem ser utilizados
simultâneamente para argumentos de passagem obrigatória (declarados
no cabeçalho da função sem valor &#8220;default&#8221;) e para argumentos
opcionais, declarados ou não(Listagem ex:passdic).</p>
<blockquote>
def fun2(a, b=1,**outros): ... print a, b, outros ... dic =
&#8216;a&#8217;:1,&#8217;b&#8217;:2,&#8217;c&#8217;:3,&#8217;d&#8217;:4 fun2(**dic) 1 2 &#8216;c&#8217;: 3, &#8216;d&#8217;: 4</blockquote>
<p>Note que no exemplo ex:passdic, os valores cujas chaves
correspondem a argumentos declarados, são atribuídos a estes e
retirados do dicionário, que fica apenas com os ítens restantes.</p>
<p>Funções podem retornar valores por meio da palavra reservada
<tt class="docutils literal"><span class="pre">return</span></tt>.</p>
<blockquote>
def soma(a,b): return a+b print &#8220;ignorado!&#8221; soma (3,4) 7</blockquote>
<p>A palavra return indica saída imediata do bloco da função levando
consigo o resultado da expressão à sua direita.{return}</p>
</div>
<div class="section" id="fun-es-lambda">
<h3>Funções lambda<a class="headerlink" href="#fun-es-lambda" title="Link permanente para este título">¶</a></h3>
<p>{lambda} Funções lambda são pequenas funções anônimas que podem ser
definidas em apenas uma linha. Por definição, podem conter uma
única expressão.</p>
<blockquote>
def raiz(n):definindo uma raiz de ordem n return
lambda(x):x**(1./n) r4 = raiz(4)r4 calcula a raiz de ordem 4
r4(16) utilizando 2</blockquote>
<p>Observe no exemplo (ex:lamb), que lambda lembra a definição de
variáveis do espaço de nome em que foi criada. Assim, <tt class="docutils literal"><span class="pre">r4</span></tt> passa
a ser uma função que calcula a raiz quarta de um número. Este
exemplo nos mostra que podemos modificar o funcionamento de uma
função durante a execução do programa: a função raiz retorna uma
função raiz de qualquer ordem, dependendo do argumento que receba.
{Geradores}{geradores} Geradores são um tipo especial de função que
retém o seu estado de uma chamada para outra. São muito
convenientes para criar iteradores, ou seja, objetos que possuem o
método <tt class="docutils literal"><span class="pre">next()</span></tt>.</p>
<blockquote>
def letras(palavra): for i in palavra: yield i for L in
letras(&#8216;gato&#8217;): print L g a t o</blockquote>
<p>Como vemos na listagem ex:ger um gerador é uma função sobre a qual
podemos iterar. {Decoradores}{decoradores} Decoradores são uma
alteração da sintaxe do Python, introduzida a partir da versão 2.4,
para facilitar a modificação de funções (sem alterá-las),
adicionando funcionalidade. Nesta seção vamos ilustrar o uso básico
de decoradores. Usos mais avançados podem ser encontrados nesta
url: http://wiki.python.org/moin/PythonDecoratorLibrary.</p>
<blockquote>
def faznada(f): def novaf(*args,**kwargs): print
&#8220;chamando...&#8221;,args,kwargs return f(*args,**kwargs) novaf.name =
f.name novaf.doc = f.doc novaf.dict.update(f.dict) return novaf</blockquote>
<p>Na listagem ex:dec, vemos um decorador muito simples. Como seu nome
diz, não faz nada, além de ilustrar a mecânica de um decorador.
Decoradores esperam um único argumento: uma função. A listagem
ex:decuso, nos mostra como utilizar o decorador.</p>
<blockquote>
<p>&#64;faznada def soma(a,b): return a+b</p>
<p>soma(1,2) chamando... (1, 2) Out[5]:3</p>
</blockquote>
<p>O decorador da listagem ex:dec, na verdade adiciona uma linha de
código à função que decora: {print &#8220;chamando...&#8221;,args,kwargs}.</p>
<p>Repare que o decorador da listagem ex:dec, passa alguns atributos
básicos da função original para a nova função, de forma que a
função decorada possua o mesmo nome, docstring, etc. que a funçao
original. No entanto, esta passagem de atributos &#8220;polui&#8221; o código
da função decoradora. Podemos evitar a poluição e o trabalho extra
utilizando a funcionalidade do módulo functools.</p>
<blockquote>
from functools import wraps def meuDecorador(f): ... &#64;wraps(f) ...
def novaf(*args, **kwds): ... print &#8216;Chamando funcao decorada &#8216;
... return f(*args, **kwds) ... return novaf ... &#64;meuDecorador
... def exemplo(): ... &#8220;&#8221;&#8220;Docstring&#8221;&#8220;&#8221; ... print &#8216;funcao exemplo
executada!&#8217; ... exemplo() Chamando funcao decorada funcao exemplo
executada! exemplo.name &#8216;exemplo&#8217; exemplo.doc &#8216;Docstring&#8217;</blockquote>
<p>Decoradores nao adicionam nenhuma funcionalidade nova ao que já é
possível fazer com funções, mas ajudam a organizar o código e
reduzir a necessidade duplicação. Aplicações científicas de
decoradores são raras, mas a sua presença em pacotes e módulos de
utilização genérica vem se tornando cada vez mais comum. Portanto,
familiaridade com sua sintaxe é aconselhada.
{Strings de Documentação} Strings posicionadas na primeira linha de
uma função, ou seja, diretamente abaixo do cabeçalho, são
denominadas strings de documentação, ou simplesmente
<tt class="docutils literal"><span class="pre">docstrings</span></tt>.</p>
<p>Estas strings devem ser utilizadas para documentar a função
explicitando sua funcionalidade e seus argumentos. O conteúdo de
uma docstring está disponível no atributo {\_\_doc\_\_} da
função.</p>
<p>Ferramentas de documentação de programas em Python extraem estas
strings para montar uma documentação automática de um programa. A
função help(nome_da_função) também retorna a docstring. Portanto
a inclusão de docstrings auxilia tanto o programador quanto o
usuário.</p>
<blockquote>
<p>def soma(a,b): &#8220;&#8221;&#8221; Esta funcao soma dois numeros: soma(2,3) 5 &#8220;&#8221;&#8221;
return a+b help(soma) Help on function soma in module main:</p>
<p>soma(a, b) Esta funcao soma dois numeros: soma(2,3) 5</p>
</blockquote>
<p>No exemplo ex:docst, adicionamos uma docstring explicando a
finalidade da função soma e ainda incluímos um exemplo. Incluir um
exemplo de uso da função cortado e colado diretamente do console
Python (incluindo o resultado), nos permitirá utilizar o módulo
<tt class="docutils literal"><span class="pre">doctest</span></tt> para testar funções, como veremos mais adiante.
{Módulos e Pacotes}{módulos} Para escrever programas de maior porte
ou agregar coleções de funções e/ou objetos criados pelo usuário, o
código Python pode ser escrito em um arquivo de texto, salvo com a
terminação <tt class="docutils literal"><span class="pre">.py</span></tt>, facilitando a re-utilização daquele código.
Arquivos com código Python contruídos para serem importados, são
denominados &#8220;módulo&#8221;. {import} Existem algumas variações na forma
de se importar módulos. O comando <tt class="docutils literal"><span class="pre">import</span> <span class="pre">meumodulo</span></tt> cria no
espaço de nomes um objeto com o mesmo nome do módulo importado.
Funções, classes (ver capítulo cap:obj) e variáveis definidas no
módulo são acessíveis como atributos deste objeto. O comando
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">modulo</span> <span class="pre">import</span> <span class="pre">*</span></tt> importa todas as funções e classes
definidas pelo módulo diretamente para o espaço de nomes
global <a class="footnote-reference" href="#id137" id="id29">[11]</a> do nosso script. Deve ser utilizado com cuidado pois
nomes iguais pré-existentes no espaço de nomes global serão
redefinidos. Para evitar este risco, podemos substituir o <tt class="docutils literal"><span class="pre">*</span></tt> por
uma sequência de nomes correspondente aos objetos que desejamos
importar: <tt class="docutils literal"><span class="pre">from</span> <span class="pre">modulo</span> <span class="pre">import</span> <span class="pre">nome1,</span> <span class="pre">nome2</span></tt>. Podemos ainda
renomear um objeto ao importá-lo: <tt class="docutils literal"><span class="pre">import</span> <span class="pre">numpy</span> <span class="pre">as</span> <span class="pre">N</span></tt> ou ainda
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">numpy</span> <span class="pre">import</span> <span class="pre">det</span> <span class="pre">as</span> <span class="pre">D</span></tt>.</p>
<p>[float,frame=trBL, caption=Módulo exemplo, label=ex:modfib] {code/fibo.py}</p>
<p>Seja um pequeno módulo como o do exemplo ex:modfib. Podemos
importar este módulo em uma sessão do interpretador iniciada no
mesmo diretório que contém o módulo (exemplo ex:import).</p>
<blockquote>
import fibo fibo.fib(50) 1 1 2 3 5 8 13 21 34 fibo.name &#8216;fibo&#8217;</blockquote>
<p>Note que a função declarada em <tt class="docutils literal"><span class="pre">fibo.py</span></tt> é chamada como um método
de <tt class="docutils literal"><span class="pre">fibo</span></tt>. Isto é porque módulos importados são objetos (como
tudo o mais em Python).</p>
<p>Quando um módulo é importado ou executado diretamente , torna-se um
objeto com um atributo {\_\_name\_\_}. O conteúdo deste
atributo depende de como o módulo foi executado. Se foi executado
por meio de importação, {\_\_name\_\_} é igual ao nome do
módulo (sem a terminação &#8220;.py&#8221;). Se foi executado diretamente
(<tt class="docutils literal"><span class="pre">python</span> <span class="pre">modulo.py</span></tt>), {\_\_name\_\_} é igual a
{``\_\_main\_\_&#8217;&#8216;}.</p>
<p>Durante a importação de um módulo, todo o código contido no mesmo é
executado, entretanto como o {\_\_name\_\_} de fibo é
<tt class="docutils literal"><span class="pre">``fibo''</span></tt> e não {``\_\_main\_\_&#8217;&#8216;}, as linhas abaixo
do <tt class="docutils literal"><span class="pre">if</span></tt> não são executadas. Qual então a função destas linhas de
código? Módulos podem ser executados diretamente pelo
interpretador, sem serem importados primeiro. Vejamos isso no
exemplo ex:runmod. Podemos ver que agora o {\_\_name\_\_}
do módulo é {``\_\_main\_\_&#8217;&#8216;} e, portanto, as linhas de
código dentro do bloco <tt class="docutils literal"><span class="pre">if</span></tt> são executadas. Note que neste caso
importamos o módulo <tt class="docutils literal"><span class="pre">sys</span></tt>, cujo atributo <tt class="docutils literal"><span class="pre">argv</span></tt> nos retorna uma
lista com os argumentos passados para o módulo a partir da posição
<span class="math">$1$</span>. A posição <span class="math">$0$</span> é sempre o nome do módulo.</p>
<blockquote>
:math:<a href="#id30"><span class="problematic" id="id31">`</span></a>$ python fibo.py 60</blockquote>
<p>__main__
[&#8216;fibo.py&#8217;, &#8216;60&#8217;]
1 1 2 3 5 8 13 21 34 55
end{lstlisting}</p>
<p>Qualquer arquivo com terminação  <a href="#id32"><span class="problematic" id="id33">*</span></a>.py} é considerado um módulo Python pelo interpretador Python. Módulos podem ser executados diretamente ou <a href="#id34"><span class="problematic" id="id35">``</span></a>importados&#8217;&#8217; por outros módulos.</p>
<p>A linguagem Python tem como uma de suas principais vantagens uma biblioteca bastante ampla de módulos, incluída com a distribuição básica da linguagem. Nesta seção vamos explorar alguns módulos da biblioteca padrão do Python, assim como outros, módulos que podem ser obtidos e adicionados à sua instalação do Python.</p>
<p>Para simplicidade de distribuição e utilização, módulos podem ser agrupados em <a href="#id36"><span class="problematic" id="id37">``</span></a>pacotes&#8217;&#8216;. Um pacote nada mais é do que um diretório contendo um arquivo denominado <a href="#id38"><span class="problematic" id="id39">*</span></a>__init__.py} (este arquivo não precisa conter nada). Portanto, pode-se criar um pacote simplesmente criando um diretório chamado, por exemplo, <a href="#id40"><span class="problematic" id="id41">``</span></a>pacote&#8217;&#8217; contendo os seguintes módulos: <a href="#id42"><span class="problematic" id="id43">*</span></a>modulo1.py} e <a href="#id44"><span class="problematic" id="id45">*</span></a>modulo2.py}footnote{Além de <a href="#id46"><span class="problematic" id="id47">*</span></a>__init__.py}, naturalmente.}. Um pacote pode conter um número arbitrário de módulos, assim como outros pacotes.</p>
<p>Como tudo o mais em Python, um pacote também é um objeto. Portanto, ao importar o pacote <a href="#id48"><span class="problematic" id="id49">``</span></a>pacote&#8217;&#8217; em uma sessão Python, modulo1 e modulo2 aparecerão como seus atributos (listagem ref{ex:importing}).
begin{lstlisting}[caption=importing a package,label=ex:importing]
&gt;&gt;&gt; import pacote
&gt;&gt;&gt; dir(pacote)
[&#8216;modulo1&#8217;,&#8217;modulo2&#8217;]
end{lstlisting}
index{pacotes}</p>
<p>subsection{Pacotes Úteis para Computação Científica}
subsubsection{<a href="#id50"><span class="problematic" id="id51">*</span></a>Numpy}}
Um dos pacotes mais importantes, senão o mais importante para quem deseja utilizar o Python em computação científica, é o <a href="#id52"><span class="problematic" id="id53">*</span></a>numpy}. Este pacote contém uma grande variedade de módulos voltados para resolução de problemas numéricos de forma eficiente.</p>
<p>Exemplos de objetos e funções pertencentes ao pacote <a href="#id54"><span class="problematic" id="id55">*</span></a>numpy} aparecerão regularmente na maioria dos exemplos deste livro. Uma lista extensiva de exemplos de Utilização do Numpy pode ser consultada neste endereço: url{<a class="reference external" href="http://www.scipy.org/Numpy_Example_List">http://www.scipy.org/Numpy_Example_List</a>}</p>
<p>Na listagem ref{ex:det}, vemos um exemplo de uso típico do <a href="#id56"><span class="problematic" id="id57">*</span></a>numpy}. O <a href="#id58"><span class="problematic" id="id59">*</span></a>numpy} nos oferece um objeto matriz, que visa representar o conceito matemático de matriz. Operações matriciais derivadas da algebra linear, são ainda oferecidas como funções através do subpacote linalg (Listagem ref{ex:det}).</p>
<p>index{numpy}
index{módulos!numpy}</p>
<p>begin{lstlisting}[ caption=Calculando e mostrando o determinante de uma matriz. ,label=ex:det]
&gt;&gt;&gt; from numpy import *
&gt;&gt;&gt; a = arange(9)
&gt;&gt;&gt; print a
[0 1 2 3 4 5 6 7 8]
&gt;&gt;&gt; a.shape =(3,3)
&gt;&gt;&gt; print a
[[0 1 2]</p>
<blockquote>
[3 4 5]
[6 7 8]]</blockquote>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">det</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go">\end{lstlisting}</span>
</pre></div>
</div>
<p>Na primeira linha do exemplo ref{ex:det}, importamos todas as funções e classes definidas no módulo numpy.</p>
<p>Na segunda linha, usamos o comando <a href="#id60"><span class="problematic" id="id61">*</span></a>arange(9)} para criar um vetor <a href="#id62"><span class="problematic" id="id63">*</span></a>a}  de 9 elementos. Este comando é equivalente ao <a href="#id64"><span class="problematic" id="id65">*</span></a>range} para criar listas, só que retorna um vetor (matriz unidimensional). Note que este vetor é composto de números inteiros sucessivos começando em zero. Todas as enumerações em Python começam em zero. Como em uma lista, <a href="#id66"><span class="problematic" id="id67">*</span></a>a[0]} é o primeiro elemento do vetor <a href="#id68"><span class="problematic" id="id69">*</span></a>a}. O objeto que criamos, é do tipo textbf{array}, definido no módulo <a href="#id70"><span class="problematic" id="id71">*</span></a>numpy}. Uma outra forma de criar o mesmo objeto seria:
<a href="#id72"><span class="problematic" id="id73">*</span></a>a = array([0,1,2,3,4,5,6,7,8])}.</p>
<p>index{arange}
index{print}</p>
<p>Na terceira linha, nós mostramos o conteúdo da variável <a href="#id74"><span class="problematic" id="id75">*</span></a>a} com o comando <a href="#id76"><span class="problematic" id="id77">*</span></a>print}. Este comando imprime na tela o valor de uma variável.</p>
<p>index{array}
index{array!.shape}</p>
<p>Como tudo em Python é um objeto, o objeto array apresenta diversos métodos e atributos. O atributo chamado <a href="#id78"><span class="problematic" id="id79">*</span></a>shape} contém o formato da matriz como uma tupla, que pode ser multi-dimensional ou não. Portanto, para converter vetor <a href="#id80"><span class="problematic" id="id81">*</span></a>a} em uma matriz <a href="#id82"><span class="problematic" id="id83">*</span></a>3$`:math:<a href="#id84"><span class="problematic" id="id85">`</span></a>$3}, basta atribuir o valor <a href="#id86"><span class="problematic" id="id87">*</span></a>(3,3)} a <a href="#id88"><span class="problematic" id="id89">*</span></a>shape}. Conforme já vimos, atributos e métodos de objetos são referenciados usando-se esta notação de pontofootnote{nome_da_variável.atributo}.</p>
<p>Na quinta linha, usamos o comando <a href="#id90"><span class="problematic" id="id91">*</span></a>print} para mostrar a alteração na forma da variável <a href="#id92"><span class="problematic" id="id93">*</span></a>a}.</p>
<p>index{módulo!numpy.linalg}</p>
<p>Na sexta linha importamos a função <a href="#id94"><span class="problematic" id="id95">*</span></a>det} do módulo <a href="#id96"><span class="problematic" id="id97">*</span></a>numpy.linalg} para calcular o determinante da nossa matriz. A função <a href="#id98"><span class="problematic" id="id99">*</span></a>det(a)} nos informa, então, que o determinante da matriz <a href="#id100"><span class="problematic" id="id101">*</span></a>a} é <a href="#id102"><span class="problematic" id="id103">*</span></a>0.0}.
subsubsection{<a href="#id104"><span class="problematic" id="id105">*</span></a>Scipy}}
index{scipy}
index{módulo!scipy}
Outro módulo muito útil para quem faz computação numérica com Python, é o <a href="#id106"><span class="problematic" id="id107">*</span></a>scipy}. O <a href="#id108"><span class="problematic" id="id109">*</span></a>scipy} depende do numpy e provê uma grande coleção de rotinas numéricas voltadas para aplicações em matemática, engenharia e estatística.</p>
<p>Diversos exemplos da segunda parte deste livro se utilizarão do scipy, portanto, não nos extenderemos em exemplos de uso do <a href="#id110"><span class="problematic" id="id111">*</span></a>scipy}.</p>
<p>Uma lista extensa de exemplos de utilização do <a href="#id112"><span class="problematic" id="id113">*</span></a>scipy} pode ser encontrada no seguinte endereço:url{<a class="reference external" href="http://www.scipy.org/Documentation">http://www.scipy.org/Documentation</a>}.</p>
<p>section{Documentando Programas}
Parte importante de um bom estilo de trabalho em computação científica é a documentação do código produzido. Apesar do Python ser uma linguagem bastante clara e de fácil leitura por humanos, uma boa dose de documentação é sempre positiva.</p>
<p>O Python facilita muito a tarefa tanto do documentador quanto do usuário da documentação de um programa. Naturalmente, o trabalho de documentar o código deve ser feito pelo programador, mas todo o resto é feito pela própria linguagem.</p>
<p>A principal maneira de documentar programas em Python é através da adição de strings de documentação (<a href="#id114"><span class="problematic" id="id115">``</span></a>docstrings&#8217;&#8216;) a funções e classes ao redigir o código. Módulos também podem possuir <a href="#id116"><span class="problematic" id="id117">``</span></a>docstrings&#8217;&#8217; contendo uma sinopse da sua funcionalidade. Estas strings servem não somente como referência para o próprio programador durante o desenvolvimento, como também como material para ferramentas de documentação automática. A principal ferramenta de documentação disponível para desenvolvedores é o <a href="#id118"><span class="problematic" id="id119">*</span></a>pydoc}, que vem junto com a distribuição  da linguagem.</p>
<p>subsection{Pydoc}index{pydoc}
O <a href="#id120"><span class="problematic" id="id121">*</span></a>pydoc} é uma ferramenta que extrai e formata a documentação de programas Python. Ela pode ser utilizada de dentro do console do interpretador Python, ou diretamente do console do Linux.
begin{lstlisting}[caption= ,label=]
$`</p>
<blockquote>
pydoc pydoc</blockquote>
<p>No exemplo acima, utilizamos o <tt class="docutils literal"><span class="pre">pydoc</span></tt> para examinar a
documentação do próprio módulo pydoc. Podemos fazer o mesmo para
acessar qualquer módulo disponível no <tt class="docutils literal"><span class="pre">PYTHONPATH</span></tt>.</p>
<p>O <tt class="docutils literal"><span class="pre">pydoc</span></tt> possui algumas opções de comando muito úteis:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-k <var>palavra</var></span></kbd></td>
<td><p class="first">Procura por palavras na documentação de todos os módulos.</p>
<p>[-p porta nome] Gera a documentação em html iniciando um servidor
HTTP na porta especificada da máquina local.</p>
<p>[-g] Útil para sistemas sem fácil acesso ao console, inicia um
servidor HTTP e abre uma pequena janela para busca.</p>
<p class="last">[-w nome] escreve a documentação requisitada em formato HTML, no
arquivo <tt class="docutils literal"><span class="pre">&lt;nome&gt;.html</span></tt>, onde <tt class="docutils literal"><span class="pre">&lt;nome&gt;</span></tt> pode ser um módulo
instalado na biblioteca local do Python ou um módulo ou pacote em
outra parte do sistema de arquivos. Muito útil para gerar
documentação para programas que criamos.</p>
</td></tr>
</tbody>
</table>
<p>Além do <tt class="docutils literal"><span class="pre">pydoc</span></tt>, outras ferramentas mais sofisticadas,
desenvolvidas por terceiros, estão disponíveis para automatizar a
documentação de programas Python. Exploraremos uma alternativa a
seguir. {Epydoc} O <tt class="docutils literal"><span class="pre">Epydoc</span></tt> é uma ferramenta consideravelmente
mais sofisticada do que o módulos <tt class="docutils literal"><span class="pre">pydoc</span></tt>. Além de prover a
funcionalidade já demontrada para o <tt class="docutils literal"><span class="pre">pydoc</span></tt>, oferece outras
facilidades como a geração da documentação em formato <tt class="docutils literal"><span class="pre">PDF</span></tt> ou
<tt class="docutils literal"><span class="pre">HTML</span></tt> e suporte à formatação das &#8220;docstrings&#8221;.</p>
<p>O uso do Epydoc é similar ao do <tt class="docutils literal"><span class="pre">pydoc</span></tt>. Entretanto, devido à sua
maior versatilidade, suas opções são bem mais numerosas (ex:epdh).</p>
<blockquote>
epydoc -h</blockquote>
<p>Não vamos discutir em detalhes as várias opções do <tt class="docutils literal"><span class="pre">Epydoc</span></tt> pois
estas encontram-se bem descritas na página <tt class="docutils literal"><span class="pre">man</span></tt> do programa.
Ainda assim, vamos comentar algumas funcionalidades interessantes.</p>
<p>A capacidade de gerar a documentação em , facilita a customização
da mesma pelo usuário e a exportação para outros formatos. A opção
<tt class="docutils literal"><span class="pre">--url</span></tt>, nos permite adicionar um link para o website de nosso
projeto ao cabeçalho da documentação. O <tt class="docutils literal"><span class="pre">Epydoc</span></tt> também verifica
o quão bem nosso programa ou pacote encontra-se documentado.
Usando-se a opção <tt class="docutils literal"><span class="pre">--check</span></tt> somos avisados sobre todos os objetos
não documentados.</p>
<p>A partir da versão 3.0, o <tt class="docutils literal"><span class="pre">Epydoc</span></tt> adiciona links para o código
fonte na íntegra, de cada elemento de nosso módulo ou pacote. A
opção <tt class="docutils literal"><span class="pre">--graph</span></tt> pode gerar três tipos de gráficos sobre nosso
programa, incluindo um diagrama <a href="#id122"><span class="problematic" id="id123">``</span></a>UML``(Figura fig:epydoc).</p>
<p>Dada toda esta funcionalidade, vale apena conferir o Epydoc <a class="footnote-reference" href="#id138" id="id124">[12]</a>.</p>
</div>
</div>
<div class="section" id="exerc-cios">
<h2>Exercícios<a class="headerlink" href="#exerc-cios" title="Link permanente para este título">¶</a></h2>
<ol class="arabic simple">
<li>Repita a iteração do exemplo ex:enumerate sem utilizar a função
enumerate. Execute a iteração do objeto gerado por <tt class="docutils literal"><span class="pre">enumerate</span></tt>
manualmente, sem o auxílio do laço <tt class="docutils literal"><span class="pre">for</span></tt> e observe o seu
resultado.</li>
<li>Adicione a funcionalidade <tt class="docutils literal"><span class="pre">else</span></tt> à listagem ex:brdict utilizando
exceções.</li>
<li>Escreva um exemplo de iteração empregando <tt class="docutils literal"><span class="pre">break</span></tt>, <tt class="docutils literal"><span class="pre">continue</span></tt> e
<a href="#id125"><span class="problematic" id="id126">``</span></a>else``(ao final).</li>
</ol>
<table class="docutils footnote" frame="void" id="id127" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[1]</a></td><td>Todos os processos no Linux e outros sistemas operacionais possuem
vias de entrada e saída de dados denominados de stdin e stdout,
respectivamente.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id128" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[2]</a></td><td>Repare como o Python trata a divisão de dois inteiros. Ela retorna
o resultado arredondado para baixo</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id129" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[3]</a></td><td>Assim como os outros tipos de números.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id130" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[4]</a></td><td>Mais quaisquer variáveis explicitamente definidas como globais</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id131" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[5]</a></td><td>O inverso do operador <tt class="docutils literal"><span class="pre">in</span></tt>, é o operador <tt class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt> e também é
válido para todas as sequências.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id132" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[6]</a></td><td><strong>Verdadeiro e falso:</strong> Em Python, quase qualquer coisa pode ser
utilizada em um contexto booleano, ou seja, como verdadeiro ou
falso. Por exemplo <tt class="docutils literal"><span class="pre">0</span></tt> é falso enquanto que todos os outros
números são verdadeiros.Uma string, lista, dicionário ou tupla
vazias sào falsas enquanto que as demais são verdadeiras.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id133" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[7]</a></td><td>Por convenção representa-se conjuntos por letras maiúsculas.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id134" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[8]</a></td><td>Os erros tratados nesta seção não são erros de sintaxe mas erros
que ocorrem durante a execução de programas sintaticamente
corretos. Estes erros serão denomidados <tt class="docutils literal"><span class="pre">exceções</span></tt></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id135" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[9]</a></td><td>Veja o capítulo 2 para uma explicação do que são métodos.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id136" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[10]</a></td><td>O leitor, neste ponto deve estar imaginando todo tipo de coisas
interessantes que podem advir de se adicionar um método
{\_\_call\_\_} a objetos normalmente não &#8220;chamáveis&#8221;.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id137" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id29">[11]</a></td><td>Dicionário de nomes de variáveis e funções válidos durante a
execução de um script</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id138" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id124">[12]</a></td><td><a class="reference external" href="http://epydoc.sourceforge.net">http://epydoc.sourceforge.net</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Tabela de Conteúdo</a></h3>
            <ul>
<li><a class="reference external" href="">Fundamentos da Linguagem</a><ul>
<li><a class="reference external" href="#primeiras-impress-es">Primeiras impressões</a><ul>
<li><a class="reference external" href="#opera-es-com-n-meros">Operações com Números</a></li>
</ul>
</li>
<li><a class="reference external" href="#nomes-objetos-e-espa-os-de-nomes">Nomes, Objetos e Espaços de Nomes</a></li>
<li><a class="reference external" href="#estruturas-de-dados">Estruturas de Dados</a><ul>
<li><a class="reference external" href="#tuplas">Tuplas</a></li>
<li><a class="reference external" href="#strings">Strings</a></li>
<li><a class="reference external" href="#conjuntos">Conjuntos</a></li>
</ul>
</li>
<li><a class="reference external" href="#controle-de-fluxo">Controle de fluxo</a><ul>
<li><a class="reference external" href="#itera-o">Iteração</a></li>
<li><a class="reference external" href="#lidando-com-erros-exce-es">Lidando com erros: Exceções</a></li>
<li><a class="reference external" href="#fun-es-lambda">Funções lambda</a></li>
</ul>
</li>
<li><a class="reference external" href="#exerc-cios">Exercícios</a></li>
</ul>
</li>
</ul>

            <h3>Esta Página</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/stuff/Cap2.txt"
                     rel="nofollow">Exibir Fonte</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Pesquisa rápida</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Ir" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Informe os termos para pesquisa ou um módulo, classe ou nome de função.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             >índice</a></li>
        <li><a href="../index.html">LivroPython v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, Flávio Codeço Coelho.
      Criado com <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.3.
    </div>
  </body>
</html>